---
title: Swarm Tools Documentation
description: Multi-agent coordination that survives context death and learns from outcomes
---

<div className="ascii-banner glow-amber mb-8">
```
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘  â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â•â•
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â•šâ•â•â•â•â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•     â•šâ•â•    â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•
                                    ğŸ
```
</div>

## The Problem

You're working with an AI coding agent. You ask it to "add OAuth authentication." It starts writing code. Five minutes later, you realize it's going down the wrong path. Or it's touching files it shouldn't. Or it's making changes that conflict with what you just did in another session.

**The fundamental issue:** AI agents are single-threaded, context-limited, and have no memory of what worked before.

## The Solution

What if the agent could:
- **Break the task into pieces** that can be worked on simultaneously
- **Spawn parallel workers** that don't step on each other
- **Remember what worked** and avoid patterns that failed
- **Survive context compaction** without losing progress

**That's what Swarm does.**

## How It Works

```
                            "Add OAuth"
                                 â”‚
                                 â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      COORDINATOR       â”‚
                    â”‚                        â”‚
                    â”‚  1. Query CASS         â”‚
                    â”‚  2. Pick strategy      â”‚
                    â”‚  3. Break into pieces  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â–¼                     â–¼                     â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Worker A   â”‚       â”‚  Worker B   â”‚       â”‚  Worker C   â”‚
    â”‚ auth/oauth  â”‚       â”‚ auth/sessionâ”‚       â”‚ auth/tests  â”‚
    â”‚   ğŸ”’ files  â”‚       â”‚   ğŸ”’ files  â”‚       â”‚   ğŸ”’ files  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The **opencode-swarm-plugin** is what you install and use. It provides:

- **Task decomposition** - Breaks complex requests into parallel subtasks
- **File reservations** - Prevents edit conflicts between workers
- **Learning system** - Tracks what strategies work (fast + success = good, slow + errors = bad)
- **Skills** - Knowledge packages agents can load when needed
- **Beads** - Git-backed issue tracking integrated with swarm coordination

Under the hood, it uses **swarm-mail** for event sourcing and actor-model messaging. That's the infrastructure layerâ€”interesting if you're building your own coordination system, but you don't need to think about it to use the plugin.

## What Makes It Different

**1. Survives Context Death**

Agents checkpoint progress at 25%, 50%, 75%. When context compaction happens, work resumes from the last checkpointâ€”no lost progress.

**2. Learns From Outcomes**

Every completed task records learning signals:
- Fast completion + zero errors â†’ Pattern gets promoted
- Slow + retries + errors â†’ Pattern gets demoted
- >60% failure rate â†’ Pattern auto-inverts to anti-pattern

**3. Has Skills**

Bundled knowledge packages for common domains:
- `testing-patterns` - Feathers dependency-breaking techniques
- `swarm-coordination` - Multi-agent orchestration
- `cli-builder` - Argument parsing, help text, subcommands
- `learning-systems` - Confidence decay, pattern maturity

## Quick Start

```bash
npm install -g opencode-swarm-plugin@latest
swarm setup
```

Then in OpenCode:

```typescript
/swarm "Add user authentication with OAuth"
```

The plugin queries past decompositions (via CASS), picks a strategy, creates beads, spawns workers, and tracks learning signals.

## What's Included

**opencode-swarm-plugin** - The plugin you install (40+ tools):

| Category | Tools | Purpose |
|----------|-------|---------|
| **Beads** | 8 tools | Git-backed issue tracking with atomic epic creation |
| **Swarm Mail** | 6 tools | Inter-agent messaging with file reservations |
| **Swarm** | 20+ tools | Task decomposition, parallel orchestration, learning |
| **Skills** | 4 tools | Knowledge injection with bundled domain expertise |

[View all plugin tools â†’](/docs/packages/opencode-plugin)

**swarm-mail** - Event sourcing infrastructure (used by the plugin):

If you're building your own agent coordination system, swarm-mail provides the primitives:

```bash
bun add swarm-mail
```

[View swarm-mail architecture â†’](/docs/packages/swarm-mail)

## Examples

### Swarm Coordination (Plugin)

```typescript
// In OpenCode, use the /swarm command:
/swarm "Add user authentication with OAuth"

// The plugin:
// 1. Queries CASS for similar past decompositions
// 2. Generates a strategy-specific decomposition
// 3. Creates epic + subtasks atomically
// 4. Spawns parallel worker agents
// 5. Tracks progress via Agent Mail
// 6. Records learning signals for future improvements
```

### File Reservations

```typescript
import { reserveSwarmFiles, releaseSwarmFiles } from 'swarm-mail';

// Reserve files before editing (prevents conflicts)
await reserveSwarmFiles(
  'WorkerA',
  ['src/auth/**', 'src/lib/jwt.ts'],
  { reason: 'bd-123.2: Auth service implementation' }
);

// Do work...

// Release when done
await releaseSwarmFiles('WorkerA');
```

### Event Sourcing (swarm-mail)

```typescript
import { getSwarmMail } from 'swarm-mail';

// Get swarm mail instance (PGLite adapter)
const swarmMail = await getSwarmMail('/my/project');

// Append events
await swarmMail.appendEvent({
  type: 'agent_registered',
  agent_name: 'WorkerA',
  task_description: 'Implementing auth service',
  timestamp: Date.now(),
});

// Query projections
const agents = await swarmMail.getAgents();
const messages = await swarmMail.getInbox('WorkerA', { limit: 5 });
```

### Durable Primitives (swarm-mail + Effect-TS)

```typescript
import { DurableMailbox, DurableLock, ask } from 'swarm-mail';
import { Effect } from 'effect';

// Actor mailbox
const mailbox = DurableMailbox.create<MyMessage>('worker-a');
await Effect.runPromise(
  mailbox.send({ type: 'task', payload: 'implement feature' })
);

// File locking with automatic release
const lock = DurableLock.create('src/auth.ts');
await Effect.runPromise(
  lock.acquire({ ttl: 60000 }).pipe(
    Effect.flatMap(() => /* do work */),
    Effect.ensuring(lock.release())
  )
);

// Request/response pattern
const response = await Effect.runPromise(
  ask<Request, Response>('other-agent', { type: 'get-types' })
);
```

## Technical Details

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     SWARM TOOLS STACK                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  TIER 3: ORCHESTRATION                                      â”‚
â”‚  â””â”€â”€ OpenCode Plugin (beads, swarm, skills, learning)      â”‚
â”‚                                                             â”‚
â”‚  TIER 2: COORDINATION                                       â”‚
â”‚  â”œâ”€â”€ DurableMailbox - Actor inbox with typed envelopes     â”‚
â”‚  â”œâ”€â”€ DurableLock - CAS-based mutual exclusion              â”‚
â”‚  â””â”€â”€ ask<Req, Res>() - Request/Response (RPC-style)        â”‚
â”‚                                                             â”‚
â”‚  TIER 1: PRIMITIVES                                         â”‚
â”‚  â”œâ”€â”€ DurableCursor - Checkpointed stream reader            â”‚
â”‚  â””â”€â”€ DurableDeferred - Distributed promise                 â”‚
â”‚                                                             â”‚
â”‚  STORAGE                                                    â”‚
â”‚  â””â”€â”€ PGLite (Embedded Postgres) + Event Sourcing           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Philosophy

**Primitives, not frameworks.** Each package solves one problem well.

- **Composable** - Mix and match what you need
- **Zero lock-in** - Works with any agent framework
- **Type-safe** - Full TypeScript with Zod schemas
- **Local-first** - PGLite embedded database, no external servers
- **Fast** - Bun-native, minimal dependencies

## Next Steps

**Get Started:**
- [Quickstart](/docs/getting-started/quickstart) - Install the plugin and run your first swarm
- [Philosophy](/docs/getting-started/philosophy) - Why Swarm Tools exists

**Using the Plugin:**
- [OpenCode Plugin Tools](/docs/packages/opencode-plugin) - All 40+ tools (beads, swarm, skills)
- [Concepts](/docs/concepts) - Event sourcing, actor model, learning systems

**Building Your Own:**
- [swarm-mail Package](/docs/packages/swarm-mail) - Event sourcing primitives and actor-model API
- [Decisions](/docs/decisions) - Architecture Decision Records (ADRs)

**Historical:**
- [Roadmap](/docs/archive/roadmap) - Future plans and experimental features
- [Credits](/docs/archive/credits) - People and projects that inspired this work

## Community

- **Website:** [swarmtools.ai](https://swarmtools.ai)
- **GitHub:** [joelhooks/opencode-swarm-plugin](https://github.com/joelhooks/opencode-swarm-plugin)
- **npm:** [opencode-swarm-plugin](https://www.npmjs.com/package/opencode-swarm-plugin), [swarm-mail](https://www.npmjs.com/package/swarm-mail)

## License

MIT - Use freely in commercial and open-source projects.
