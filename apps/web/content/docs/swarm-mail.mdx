---
title: Swarm Mail Architecture
description: Event sourcing primitives and actor-model coordination with PGLite
---

# Swarm Mail Architecture

Event sourcing primitives for multi-agent coordination. Local-first, no external servers required.

## Overview

Swarm Mail provides actor-model primitives built on event sourcing with embedded PostgreSQL (PGLite). All agent interactions are stored as immutable events with materialized views for fast queries.

**Key features:**
- Append-only event log with full audit trail
- Materialized views for agents, messages, and file reservations
- Durable primitives (mailbox, lock, cursor, deferred) with Effect-TS
- Local-first with PGLite embedded database
- Zero external dependencies

## Installation

```bash
bun add swarm-mail
```

Swarm Mail is also included in the OpenCode plugin.

---

## Event Store

The core of Swarm Mail is an append-only event log. All state changes are recorded as immutable events.

### EventStore API

```typescript
import { getSwarmMail } from 'swarm-mail';

// Get swarm mail instance (PGLite adapter)
const swarmMail = await getSwarmMail('/my/project');

// Append an event
await swarmMail.appendEvent({
  type: 'agent_registered',
  agent_name: 'WorkerA',
  task_description: 'Implementing OAuth service',
  timestamp: Date.now(),
});

// Read events
const events = await swarmMail.getEvents({ limit: 100, after: 0 });
```

### Event Types

All events share a common structure:

```typescript
type SwarmMailEvent = 
  | AgentRegisteredEvent
  | MessageSentEvent
  | MessageReadEvent
  | FileReservedEvent
  | FileReleasedEvent
  | SwarmCheckpointedEvent
  | DecompositionGeneratedEvent
  | SubtaskOutcomeEvent;
```

**AgentRegisteredEvent** - Agent joins the system:

```typescript
{
  type: "agent_registered";
  agent_name: string;
  task_description?: string;
  timestamp: number;
}
```

**MessageSentEvent** - Inter-agent message:

```typescript
{
  type: "message_sent";
  from: string;
  to: string[];
  subject: string;
  body: string;
  thread_id?: string;
  importance?: "low" | "normal" | "high" | "urgent";
  timestamp: number;
}
```

**FileReservedEvent** - File reservation for exclusive editing:

```typescript
{
  type: "file_reserved";
  agent_name: string;
  paths: string[];
  exclusive: boolean;
  reason?: string;
  ttl_seconds?: number;
  timestamp: number;
}
```

**SubtaskOutcomeEvent** - Learning signal for decomposition quality:

```typescript
{
  type: "subtask_outcome";
  bead_id: string;
  success: boolean;
  duration_ms: number;
  error_count?: number;
  retry_count?: number;
  strategy?: string;
  timestamp: number;
}
```

---

## Projections

Materialized views derived from events for fast queries. Updated atomically within the same transaction as event appends.

### Agents Projection

Active agents per project:

```typescript
const agents = await swarmMail.getAgents();
// Returns: [{ id: 1, name: "WorkerA", project_key: "/path", registered_at: ..., last_active_at: ... }]

const agent = await swarmMail.getAgent("WorkerA");
// Returns: { id: 1, name: "WorkerA", ... }
```

### Messages Projection

Agent inbox/outbox with recipients:

```typescript
const inbox = await swarmMail.getInbox("WorkerA", { limit: 5 });
// Returns: [{ id: 1, from: "Coordinator", subject: "Task assigned", ... }]

const message = await swarmMail.getMessage(42);
// Returns: { id: 42, from: "...", to: [...], body: "...", ... }

const thread = await swarmMail.getThread("bd-123");
// Returns all messages in thread (grouped by thread_id)
```

### File Reservations Projection

Current file locks with TTL:

```typescript
const reservations = await swarmMail.getReservations();
// Returns: [{ id: 1, agent_name: "WorkerA", path_pattern: "src/auth/**", expires_at: ..., ... }]

const conflicts = await swarmMail.checkConflicts(["src/auth/oauth.ts"], "WorkerB");
// Returns: [{ path: "src/auth/oauth.ts", holder: "WorkerA", ... }]
```

**Conflict detection:** Checks if paths are reserved by other agents. Supports glob patterns.

---

## Database Adapter

Dependency injection for testing and flexibility. Swarm Mail provides two approaches:

### Convenience Layer (PGLite)

Built-in PGLite adapter for quick start:

```typescript
import { getSwarmMail, createInMemorySwarmMail } from 'swarm-mail';

// Persistent (project-local .opencode/streams.db)
const swarmMail = await getSwarmMail('/my/project');

// In-memory (for testing)
const swarmMail = await createInMemorySwarmMail();

// Close when done
await closeSwarmMail('/my/project');
```

### Custom Adapter

Implement `DatabaseAdapter` for other databases:

```typescript
import { DatabaseAdapter, createSwarmMailAdapter } from 'swarm-mail';

const customAdapter: DatabaseAdapter = {
  query: async (sql, params) => {
    // Your query implementation
  },
  exec: async (sql) => {
    // Your exec implementation
  },
  transaction: async (fn) => {
    // Your transaction implementation
  },
  close: async () => {
    // Your cleanup
  }
};

const swarmMail = createSwarmMailAdapter(customAdapter, '/my/project');
```

**Database location:**
- Project-local: `{project}/.opencode/streams.db`
- Global fallback: `~/.opencode/streams.db`

---

## Durable Primitives (Effect-TS)

Type-safe, composable coordination primitives built on Effect-TS.

### DurableMailbox

Actor inbox with typed message envelopes. Messages persist across process restarts.

```typescript
import { DurableMailbox } from 'swarm-mail';
import { Effect } from 'effect';

// Define message type
type AuthMessage = 
  | { type: 'validate_token'; token: string }
  | { type: 'refresh_token'; userId: string };

// Create mailbox
const mailbox = DurableMailbox.create<AuthMessage>('auth-service');

// Send message
await Effect.runPromise(
  mailbox.send({ type: 'validate_token', token: 'abc123' })
);

// Receive messages
const program = mailbox.receive().pipe(
  Effect.tap((msg) => 
    Effect.sync(() => {
      if (msg.type === 'validate_token') {
        console.log('Validating:', msg.token);
      }
    })
  ),
  Effect.forever // Keep processing
);

await Effect.runPromise(program);
```

**Key features:**
- Type-safe message envelopes
- Persistent storage (survives restarts)
- FIFO ordering
- Effect-TS composition

---

### DurableLock

Compare-and-swap based mutual exclusion for file locking.

```typescript
import { DurableLock } from 'swarm-mail';
import { Effect } from 'effect';

const lock = DurableLock.create('src/auth.ts');

// Acquire lock, do work, ensure release
const program = lock.acquire({ ttl: 60000 }).pipe(
  Effect.flatMap(() => 
    Effect.sync(() => {
      // Do work while holding lock
      console.log('Editing src/auth.ts');
    })
  ),
  Effect.ensuring(lock.release()) // Always release
);

await Effect.runPromise(program);
```

**Key features:**
- CAS-based (optimistic concurrency)
- TTL for auto-expiry
- Holder tracking (who owns the lock)
- Sequence numbers for conflict detection

**Lock storage:** Uses `locks` table with `resource` primary key.

---

### DurableCursor

Checkpointed stream reader for exactly-once processing.

```typescript
import { DurableCursor } from 'swarm-mail';
import { Effect, Stream } from 'effect';

// Create cursor at position 0
const cursor = DurableCursor.create('my-consumer', 0);

// Process events with automatic checkpointing
const program = cursor.watch(eventStream).pipe(
  Stream.tap((event) => 
    Effect.sync(() => {
      console.log('Processing event:', event);
      // Cursor auto-checkpoints after each event
    })
  ),
  Stream.runDrain
);

await Effect.runPromise(program);
```

**Key features:**
- Automatic checkpointing after each event
- Survive process crashes (resume from last checkpoint)
- Exactly-once semantics
- Effect-TS Stream integration

**Cursor storage:** Uses `cursors` table with `consumer_name` primary key and `position` column.

---

### DurableDeferred

Distributed promise for async coordination. One agent waits for another to complete a value.

```typescript
import { DurableDeferred } from 'swarm-mail';
import { Effect } from 'effect';

// Agent A: Create deferred
const deferred = DurableDeferred.create<string>('schema-ready');

// Agent B: Wait for value
const waitProgram = deferred.await().pipe(
  Effect.tap((schema) => 
    Effect.sync(() => console.log('Got schema:', schema))
  )
);

// Agent A: Complete deferred
const completeProgram = deferred.complete('CREATE TABLE users ...');

await Effect.runPromise(Effect.all([waitProgram, completeProgram]));
```

**Key features:**
- Cross-agent async coordination
- Persistent (survives restarts)
- Type-safe value
- Effect-TS semantics

**Deferred storage:** Uses `deferred` table with `id` primary key and `value` JSONB column.

---

## Advanced Patterns

### Request/Response (RPC)

The `ask` pattern for request/response coordination:

```typescript
import { ask } from 'swarm-mail';
import { Effect } from 'effect';

// Request types
type GetTypesRequest = { type: 'get-types' };
type GetTypesResponse = { types: string[] };

// Agent A: Send request
const response = await Effect.runPromise(
  ask<GetTypesRequest, GetTypesResponse>(
    'type-generator',
    { type: 'get-types' }
  )
);

console.log('Types:', response.types);
```

**How it works:**
1. Sender creates a `DurableDeferred` with unique ID
2. Sender sends message with deferred ID
3. Receiver processes message, completes deferred
4. Sender awaits deferred completion

---

## Schema

Full database schema (created automatically by PGLite adapter):

```sql
-- Events table (append-only)
CREATE TABLE events (
  id SERIAL PRIMARY KEY,
  type TEXT NOT NULL,
  project_key TEXT NOT NULL,
  timestamp BIGINT NOT NULL,
  sequence SERIAL,
  data JSONB NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Agents projection
CREATE TABLE agents (
  id SERIAL PRIMARY KEY,
  project_key TEXT NOT NULL,
  name TEXT NOT NULL,
  program TEXT DEFAULT 'opencode',
  model TEXT DEFAULT 'unknown',
  task_description TEXT,
  registered_at BIGINT NOT NULL,
  last_active_at BIGINT NOT NULL,
  UNIQUE(project_key, name)
);

-- Messages projection
CREATE TABLE messages (
  id SERIAL PRIMARY KEY,
  project_key TEXT NOT NULL,
  from_agent TEXT NOT NULL,
  subject TEXT NOT NULL,
  body TEXT NOT NULL,
  thread_id TEXT,
  importance TEXT DEFAULT 'normal',
  ack_required BOOLEAN DEFAULT FALSE,
  created_at BIGINT NOT NULL
);

-- Message recipients (many-to-many)
CREATE TABLE message_recipients (
  message_id INTEGER REFERENCES messages(id) ON DELETE CASCADE,
  agent_name TEXT NOT NULL,
  read_at BIGINT,
  acked_at BIGINT,
  PRIMARY KEY(message_id, agent_name)
);

-- File reservations projection
CREATE TABLE reservations (
  id SERIAL PRIMARY KEY,
  project_key TEXT NOT NULL,
  agent_name TEXT NOT NULL,
  path_pattern TEXT NOT NULL,
  exclusive BOOLEAN DEFAULT TRUE,
  reason TEXT,
  created_at BIGINT NOT NULL,
  expires_at BIGINT NOT NULL,
  released_at BIGINT
);

-- Locks for DurableLock
CREATE TABLE locks (
  resource TEXT PRIMARY KEY,
  holder TEXT NOT NULL,
  seq INTEGER NOT NULL DEFAULT 0,
  acquired_at BIGINT NOT NULL,
  expires_at BIGINT NOT NULL
);

-- Cursors for DurableCursor (via migrations)
CREATE TABLE cursors (
  consumer_name TEXT PRIMARY KEY,
  position INTEGER NOT NULL,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Deferred for DurableDeferred (via migrations)
CREATE TABLE deferred (
  id TEXT PRIMARY KEY,
  value JSONB,
  completed_at TIMESTAMP
);
```

---

## Performance Characteristics

| Operation | Latency | Notes |
|-----------|---------|-------|
| Event append | ~10ms | Single INSERT |
| Projection update | ~5ms | Within same transaction |
| Inbox query | ~5ms | Indexed on project_key + agent_name |
| Conflict check | ~10ms | Glob pattern matching |

**Concurrency model:**
- PGLite is single-process, single-threaded
- Transactions provide isolation for multi-statement operations
- Concurrent reads are safe (no locks needed)
- Concurrent writes are serialized by PGLite internally

**Known limitations:**
- No distributed locking (single-process only)
- Large transactions may block other operations
- No connection pooling (embedded database)

---

## Thread Safety

PGLite runs in-process as a single-threaded SQLite-compatible database. While Node.js is single-threaded, async operations can interleave.

**Race condition mitigations:**
- File reservations use INSERT with conflict detection
- Sequence numbers are auto-incremented by database
- Materialized views updated within same transaction as events
- Pending instance promises prevent duplicate initialization

**Singleton pattern:** One PGLite instance per project (LRU cache with max 10 instances).

---

## Testing

Swarm Mail provides in-memory mode for fast tests:

```typescript
import { createInMemorySwarmMail, closeAllSwarmMail } from 'swarm-mail';
import { describe, it, expect, afterAll } from 'bun:test';

describe('My Agent', () => {
  afterAll(async () => {
    await closeAllSwarmMail();
  });

  it('sends messages', async () => {
    const swarmMail = await createInMemorySwarmMail();
    
    await swarmMail.appendEvent({
      type: 'agent_registered',
      agent_name: 'TestAgent',
      timestamp: Date.now()
    });
    
    const agents = await swarmMail.getAgents();
    expect(agents).toHaveLength(1);
  });
});
```

**Pro tip:** Use `closeAllSwarmMail()` in `afterAll()` to prevent test pollution.

---

## Debugging

Swarm Mail logs slow operations (>100ms) automatically:

```
[SwarmMail] Slow operation: appendEvent took 125.3ms
```

Debug logging goes to `~/.opencode/streams-debug.log`:

```typescript
// Enable verbose logging (internal)
const db = await getDatabase('/my/project');
// Check ~/.opencode/streams-debug.log for details
```

**Health check:**

```typescript
import { isDatabaseHealthy, getDatabaseStats } from 'swarm-mail';

const healthy = await isDatabaseHealthy('/my/project');
console.log('Healthy:', healthy);

const stats = await getDatabaseStats('/my/project');
console.log('Stats:', stats);
// { events: 1234, agents: 5, messages: 89, reservations: 3 }
```

---

## Migration to Standalone Package

Swarm Mail was extracted from the OpenCode plugin in v0.1.0. The plugin still includes it as a dependency.

**Migration guide:**
- Old: `import { EventStore } from 'opencode-swarm-plugin'`
- New: `import { getSwarmMail } from 'swarm-mail'`

The plugin's `swarmmail_*` tools are wrappers around the swarm-mail package.

---

## Next Steps

- [OpenCode Plugin Reference](/docs/opencode-plugin) - All plugin tools using swarm-mail
- [Roadmap](/docs/roadmap) - Future enhancements (live queries, pub/sub, saga pattern)
- [GitHub](https://github.com/joelhooks/opencode-swarm-plugin) - Source code and issues

## License

MIT
