---
title: Swarm Mail Architecture
description: Deep dive into event sourcing, durable primitives, and actor-model coordination
---

# Swarm Mail Architecture

```
                                  _.------._
                                .'   .--.   '.        ğŸ
                               /   .'    '.   \    ğŸ
                              |   /   __   \   |      ğŸ
    ğŸ                        |  |   (  )   |  |  ğŸ
         ğŸ    _  _           |  |   |__|   |  |
              ( \/ )           \  '.      .'  /    ğŸ
    ğŸ    ____/    \____        '.  '----'  .'
        /    \    /    \         '-._____.-'           ğŸ
       /  ()  \  /  ()  \
      |   /\   ||   /\   |     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—
      |  /__\  ||  /__\  |     â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘
       \      /  \      /      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘
    ğŸ  '----'    '----'       â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘
                               â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘
          ğŸ                   â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•
                 ğŸ
    ğŸ                         â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—
                               â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘         ğŸ
         ğŸ                    â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
                               â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    ğŸ
    ğŸ        ğŸ               â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
                               â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•šâ•â•â•â•â•â•â•       ğŸ
              ğŸ
                          âš¡ Actor-Model Primitives for Agent Coordination âš¡
```

## Overview

**Swarm Mail** is an embedded, event-sourced messaging system for multi-agent coordination. Built on **Durable Streams** primitives with Effect-TS, it provides actor-model communication without external server dependencies.

### What Problem Does It Solve?

When multiple AI agents work on the same codebase in parallel, they need to:

- **Coordinate file access** - prevent edit conflicts via reservations
- **Exchange messages** - async communication for status, blockers, handoffs
- **Request/response** - synchronous-style RPC for data queries
- **Resume after crashes** - positioned consumption with checkpointing
- **Audit all actions** - full event history for debugging and learning

Traditional solutions require external servers (Redis, Kafka, NATS). Swarm Mail is **embedded** - just PGLite (embedded Postgres) + Effect-TS.

### Key Features

- âœ… **Local-first** - No external servers, no network dependencies
- âœ… **Event-sourced** - Full audit trail of all agent actions
- âœ… **Resumable** - Checkpointed cursors for exactly-once processing
- âœ… **Type-safe** - Effect-TS with full type inference
- âœ… **Actor-model** - Mailboxes, envelopes, distributed promises
- âœ… **File safety** - CAS-based locks for mutual exclusion

---

## Architecture Stack

Swarm Mail is built in **3 tiers** - primitives, patterns, and coordination layers.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              SWARM MAIL STACK                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   TIER 3: COORDINATION                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  ask<Req, Res>() - Request/Response over Streams (RPC-style)        â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                      â”‚                                      â”‚
â”‚   TIER 2: PATTERNS                   â–¼                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚   â”‚    DurableMailbox     â”‚    â”‚     DurableLock       â”‚                    â”‚
â”‚   â”‚  Actor Inbox + Reply  â”‚    â”‚  CAS Mutual Exclusion â”‚                    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚              â”‚                           â”‚                                  â”‚
â”‚   TIER 1: PRIMITIVES                     â–¼                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚   â”‚    DurableCursor      â”‚    â”‚   DurableDeferred     â”‚                    â”‚
â”‚   â”‚  Checkpointed Reader  â”‚    â”‚  Distributed Promise  â”‚                    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                                      â”‚                                      â”‚
â”‚   STORAGE                            â–¼                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚              PGLite (Embedded Postgres) + Migrations                â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Tier 1: Durable Streams Primitives

The foundational building blocks. Inspired by Kyle Matthews' [Durable Streams protocol](https://x.com/kylemathews/status/1999896667030700098).

### DurableCursor - Positioned Event Stream Consumption

**Purpose:** Read events from a stream with resumable position tracking.

**Key Concept:** Event streams are append-only logs. Cursors track the "last read position" (sequence number) and checkpoint it to the database. If an agent crashes, it resumes from the last committed position.

**API:**

```typescript
const cursor =
  yield *
  cursorService.create({
    stream: "projects/foo/events", // Stream identifier
    checkpoint: "agents/bar/position", // Unique checkpoint name
    batchSize: 100, // Read 100 events at a time
  });

// Consume events as async iterable
for await (const msg of cursor.consume()) {
  yield * handleMessage(msg.value);
  yield * msg.commit(); // Checkpoint this position
}
```

**Implementation Details:**

- **Schema:** `cursors` table with `(stream, checkpoint)` UNIQUE constraint
- **Batching:** Reads events in batches (default 100) for efficiency
- **Commit:** Updates `position` in database + in-memory `Ref`
- **Resumability:** On restart, loads last committed position from DB

**Use Cases:**

- Inbox consumption - agent reads messages from stream
- Event processing - workers consume tasks from event log
- Exactly-once semantics - commit after processing, skip on replay

---

### DurableDeferred - Distributed Promises

**Purpose:** Create a "distributed promise" that can be resolved from anywhere (think of it as a URL-addressable future value).

**Key Concept:** You create a deferred with a unique URL, pass that URL to another agent, and block waiting for the response. The other agent resolves the deferred by URL, unblocking you.

**API:**

```typescript
// Agent A: Create deferred and send request
const deferred =
  yield *
  deferredService.create<Response>({
    ttlSeconds: 60,
  });

yield *
  mailbox.send("agent-b", {
    payload: { task: "getData" },
    replyTo: deferred.url, // URL like "deferred:abc123"
  });

const response = yield * deferred.value; // Blocks until resolved or timeout

// Agent B: Resolve deferred
yield * deferredService.resolve(envelope.replyTo, { data: "result" });
```

**Implementation Details:**

- **Schema:** `deferred` table with `url UNIQUE`, `resolved BOOLEAN`, `value JSONB`
- **In-memory registry:** `Map<url, Effect.Deferred>` for instant resolution (no polling)
- **Fallback polling:** If in-memory deferred missing (agent restart), polls database every 100ms
- **TTL expiry:** Auto-cleanup of expired deferreds
- **Errors:** `TimeoutError` if TTL expires, `NotFoundError` if URL doesn't exist

**Use Cases:**

- Request/response - ask pattern (see Tier 3)
- RPC over streams - synchronous-style calls between agents
- Coordination - agent waits for signal from another agent

---

### DurableLock - Distributed Mutual Exclusion

**Purpose:** Acquire exclusive locks on resources using Compare-And-Swap (CAS) pattern.

**Key Concept:** CAS (seq=0) pattern - try to INSERT (no lock exists) or UPDATE (lock expired or we already hold it). Uses exponential backoff for retries on contention.

**API:**

```typescript
// Acquire lock with retry
const lock =
  yield *
  lockService.acquire("my-resource", {
    ttlSeconds: 30,
    maxRetries: 10,
  });

try {
  // Critical section - only one agent here at a time
  yield * doWork();
} finally {
  yield * lock.release();
}

// Or use helper
yield * lockService.withLock("my-resource", Effect.succeed(42));
```

**Implementation Details:**

- **Schema:** `locks` table with `resource UNIQUE`, `holder TEXT`, `seq INTEGER`
- **CAS logic:**
  1. Try `INSERT` (no lock exists) â†’ success
  2. If INSERT fails, try `UPDATE WHERE expires_at < now OR holder = me` â†’ success if stale/reentrant
  3. If UPDATE returns 0 rows â†’ contention, retry with backoff
- **Exponential backoff:** 50ms base delay, doubles each retry (50ms, 100ms, 200ms...)
- **Auto-expiry:** TTL stored in `expires_at`, stale locks can be claimed
- **Errors:** `LockTimeout` if max retries exceeded, `LockNotHeld` if release by wrong holder

**Use Cases:**

- File reservations - prevent edit conflicts (Swarm Mail uses this)
- Critical sections - only one agent modifying shared state
- Leader election - first to acquire lock becomes leader

---

### DurableMailbox - Actor-Style Messaging

**Purpose:** Send/receive envelopes between agents using cursor-based positioned consumption.

**Key Concept:** Combines DurableCursor (positioned reading) + Envelope pattern (payload + metadata). Each agent has a named mailbox, messages are filtered by recipient during consumption.

**API:**

```typescript
const mailbox =
  yield *
  mailboxService.create({
    agent: "worker-1",
    projectKey: "proj-123",
  });

// Send message with optional reply channel
yield *
  mailbox.send("worker-2", {
    payload: { task: "process-data" },
    replyTo: "deferred:xyz", // For request/response
    threadId: "bd-123", // Conversation tracking
  });

// Receive messages (filters to only messages for this agent)
for await (const envelope of mailbox.receive()) {
  console.log(envelope.payload);
  if (envelope.replyTo) {
    yield * DurableDeferred.resolve(envelope.replyTo, result);
  }
  yield * envelope.commit(); // Checkpoint position
}
```

**Implementation Details:**

- **Cursor creation:** Creates `DurableCursor` with filter `types: ["message_sent"]`
- **Filtering:** `eventToEnvelope()` skips messages not addressed to this agent
- **Envelope structure:**
  ```typescript
  {
    payload: T,           // Your message data
    replyTo?: string,     // Deferred URL for response
    sender: string,       // From agent
    messageId: number,    // Message ID
    threadId?: string,    // Conversation grouping
    commit: () => Effect  // Checkpoint this message
  }
  ```
- **Storage:** Messages stored as `message_sent` events in event stream

**Use Cases:**

- Agent inbox - receive tasks, status updates, blockers
- Broadcast - send message to multiple agents
- Request/response - combine with DurableDeferred (see ask pattern)

---

## Tier 2: Coordination Patterns

Higher-level patterns built by composing primitives.

### The Ask Pattern - Request/Response over Streams

**Purpose:** Synchronous-style RPC between agents using async streams.

**How It Works:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Agent A â”‚                                                  â”‚ Agent B â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                                                  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                                                            â”‚
     â”‚ 1. Create deferred                                        â”‚
     â”‚    url = "deferred:abc123"                                â”‚
     â”‚                                                            â”‚
     â”‚ 2. Send message with replyTo=url                          â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                                            â”‚
     â”‚ 3. Block on deferred.value                                â”‚ 4. Process request
     â”‚    (waits...)                                             â”‚
     â”‚                                                            â”‚
     â”‚                                   5. Resolve deferred(url) â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚                                                            â”‚
     â”‚ 6. Unblocked, return response                             â”‚
     â”‚                                                            â”‚
```

**Code Example:**

```typescript
// Agent A (caller)
const response =
  yield *
  ask<Request, Response>({
    mailbox: myMailbox,
    to: "worker-2",
    payload: { query: "getUserData", userId: 123 },
    ttlSeconds: 30,
  });

// Agent B (responder)
for await (const envelope of mailbox.receive()) {
  const result = processRequest(envelope.payload);
  if (envelope.replyTo) {
    yield * DurableDeferred.resolve(envelope.replyTo, result);
  }
  yield * envelope.commit();
}
```

**Why This Matters:**

- **Synchronous feel, async reality** - code looks like RPC, but it's event-driven
- **Resilient** - if responder crashes, caller gets timeout (not hung forever)
- **Auditable** - all request/response pairs in event log
- **Type-safe** - full TypeScript inference for request/response types

---

### File Reservation Protocol

**Purpose:** Prevent edit conflicts when multiple agents modify files.

**Flow:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Agent A  â”‚                                          â”‚ Agent B  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                                          â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚                                                     â”‚
     â”‚ 1. Reserve src/auth.ts (exclusive)                 â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
     â”‚                                            â”‚       â”‚
     â”‚ 2. DurableLock.acquire("src/auth.ts")     â”‚       â”‚
     â”‚    â†’ Granted (no conflicts)                â”‚       â”‚
     â”‚                                            â”‚       â”‚
     â”‚ 3. Edit src/auth.ts                        â”‚       â”‚
     â”‚                                            â”‚       â”‚ 4. Reserve src/auth.ts
     â”‚                                            â”‚       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                                            â”‚       â”‚                      â”‚
     â”‚                                            â”‚       â”‚ 5. Lock contention   â”‚
     â”‚                                            â”‚       â”‚    â†’ Warned (Agent A â”‚
     â”‚                                            â”‚       â”‚       holds lock)    â”‚
     â”‚                                            â”‚       â”‚                      â”‚
     â”‚ 6. Release src/auth.ts                     â”‚       â”‚                      â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”‚                      â”‚
     â”‚                                            â”‚       â”‚                      â”‚
     â”‚ 7. DurableLock.release()                   â”‚       â”‚ 8. Retry acquire     â”‚
     â”‚                                            â”‚       â”‚    â†’ Granted         â”‚
     â”‚                                            â”‚       â”‚                      â”‚
```

**Implementation:**

- Uses `DurableLock` for mutual exclusion
- Conflicts are **warnings**, not blockers (agents can proceed with awareness)
- TTL expiry (default 1 hour) prevents deadlocks from crashed agents
- Materialized view (`reservations` table) for fast conflict queries

---

## Tier 3: High-Level APIs

The public API exposed to agents (wraps primitives + patterns).

### Swarm Mail API

These are the functions called by agents (via plugin tools or direct import):

```typescript
// Initialization
const { agentName, projectKey } = await initSwarmAgent({
  projectPath: "/abs/path",
  agentName: "BlueLake", // Optional, auto-generated if omitted
  taskDescription: "Implementing auth",
});

// Send message
await sendSwarmMessage({
  projectPath,
  fromAgent: "BlueLake",
  toAgents: ["coordinator"],
  subject: "Progress: bd-123.2",
  body: "Auth service complete",
  threadId: "bd-123",
  importance: "normal",
});

// Read inbox
const { messages } = await getSwarmInbox({
  projectPath,
  agentName: "BlueLake",
  limit: 5, // Max 5 (hard cap for context)
  urgentOnly: false,
  includeBodies: false, // Headers only by default
});

// Read full message
const message = await readSwarmMessage({
  projectPath,
  messageId: 123,
  markAsRead: true,
});

// Reserve files
const { granted, conflicts } = await reserveSwarmFiles({
  projectPath,
  agentName: "BlueLake",
  paths: ["src/auth/**"],
  reason: "bd-123.2: Auth service",
  exclusive: true,
  ttlSeconds: 3600,
});

// Release files
await releaseSwarmFiles({
  projectPath,
  agentName: "BlueLake",
  paths: ["src/auth/**"],
});
```

---

## Event Sourcing Architecture

Swarm Mail is fully event-sourced. **All state changes are events first, materialized views second.**

### Event Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Action    â”‚  Agent calls API (e.g., sendMessage)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Create    â”‚  createEvent("message_sent", {...})
â”‚   Event     â”‚  Returns: { type, timestamp, ...payload }
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Append    â”‚  appendEvent() â†’ INSERT INTO events
â”‚   to Log    â”‚  Gets auto-increment id + sequence
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Update    â”‚  updateProjections() triggers based on event type
â”‚   Views     â”‚  - message_sent â†’ INSERT messages, UPDATE agent read status
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  - file_reserved â†’ INSERT reservations
       â”‚         - message_read â†’ UPDATE message read flags
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Query     â”‚  getInbox(), getMessage(), getReservations()
â”‚   Views     â”‚  Fast queries on materialized tables
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Event Types

| Event Type         | Trigger                      | Projections Updated              |
| ------------------ | ---------------------------- | -------------------------------- |
| `agent_registered` | Agent init                   | `agents` table                   |
| `message_sent`     | sendMessage()                | `messages`, `message_recipients` |
| `message_read`     | readMessage(markAsRead=true) | `messages.read_by` JSONB         |
| `message_acked`    | acknowledgeMessage()         | `messages.acked_by` JSONB        |
| `file_reserved`    | reserveFiles()               | `reservations`                   |
| `file_released`    | releaseFiles()               | `reservations` (DELETE expired)  |

### Why Event Sourcing?

- âœ… **Full audit trail** - every agent action is logged forever
- âœ… **Time travel** - replay events to reconstruct past state
- âœ… **Debugging** - when agents conflict, trace exact sequence of events
- âœ… **Learning** - analyze event patterns to improve swarm strategies
- âœ… **Resumability** - cursors checkpoint position, replay from there on crash

---

## Comparison to Agent Mail

Swarm Mail is **inspired by** [Agent Mail](https://github.com/sst/opencode) (SST's multi-agent coordination layer) but built from scratch with different trade-offs.

| Aspect                   | Agent Mail (SST)              | Swarm Mail (This Plugin)               |
| ------------------------ | ----------------------------- | -------------------------------------- |
| **Architecture**         | MCP server (external process) | Embedded (PGLite in-process)           |
| **Storage**              | SQLite file                   | PGLite (WASM Postgres)                 |
| **Dependencies**         | Requires MCP server running   | Zero external deps, just npm install   |
| **Effect-TS**            | No                            | Yes (full Effect integration)          |
| **Event Sourcing**       | No (CRUD operations)          | Yes (append-only event log)            |
| **Cursors**              | No (queries are one-shot)     | Yes (resumable positioned consumption) |
| **Distributed Promises** | No                            | Yes (DurableDeferred)                  |
| **Type Safety**          | MCP JSON-RPC (strings)        | Full TypeScript + Zod validation       |
| **Local-First**          | Requires server               | True local-first (no network)          |
| **Learning System**      | No                            | Yes (eval records, pattern maturity)   |

**When to Use Agent Mail:**

- You're already using OpenCode with MCP infrastructure
- You need cross-project coordination (multiple repos)
- You want battle-tested SST ecosystem integration

**When to Use Swarm Mail:**

- You want embedded, zero-config coordination
- You're building Effect-TS applications
- You need event sourcing and audit trails
- You want resumable cursors for exactly-once semantics
- You're using this plugin's learning/swarm features

---

## Database Schema

Swarm Mail uses **PGLite** (embedded Postgres compiled to WASM). Schema is managed via migrations (see `src/streams/migrations.ts`).

### Core Tables

#### `events` - Append-Only Event Log

```sql
CREATE TABLE events (
  id SERIAL PRIMARY KEY,
  sequence SERIAL,              -- Auto-increment, never gaps
  type TEXT NOT NULL,           -- Event type (message_sent, file_reserved, etc.)
  timestamp BIGINT NOT NULL,    -- Unix timestamp in ms
  payload JSONB NOT NULL,       -- Event-specific data
  project_key TEXT NOT NULL,
  agent_name TEXT
);
CREATE INDEX idx_events_sequence ON events(sequence);
CREATE INDEX idx_events_type ON events(type);
CREATE INDEX idx_events_project ON events(project_key);
```

**All state changes flow through this table.** Other tables are materialized views.

---

#### `cursors` - Checkpointed Read Positions

```sql
CREATE TABLE cursors (
  id SERIAL PRIMARY KEY,
  stream TEXT NOT NULL,         -- Stream name (e.g., "projects/foo/events")
  checkpoint TEXT NOT NULL,     -- Checkpoint name (e.g., "agents/bar/position")
  position BIGINT NOT NULL,     -- Last committed sequence number
  updated_at BIGINT NOT NULL,
  UNIQUE(stream, checkpoint)
);
CREATE INDEX idx_cursors_checkpoint ON cursors(checkpoint);
```

**DurableCursor uses this to resume from last position after restart.**

---

#### `deferred` - Distributed Promises

```sql
CREATE TABLE deferred (
  id SERIAL PRIMARY KEY,
  url TEXT NOT NULL UNIQUE,     -- Unique identifier (e.g., "deferred:abc123")
  resolved BOOLEAN NOT NULL DEFAULT FALSE,
  value JSONB,                  -- Resolution value
  error TEXT,                   -- Rejection error message
  expires_at BIGINT NOT NULL,   -- TTL expiry timestamp
  created_at BIGINT NOT NULL
);
CREATE INDEX idx_deferred_url ON deferred(url);
CREATE INDEX idx_deferred_expires ON deferred(expires_at);
```

**DurableDeferred uses this for URL-addressable futures.**

---

#### `locks` - CAS-Based Mutual Exclusion

```sql
CREATE TABLE locks (
  id SERIAL PRIMARY KEY,
  resource TEXT NOT NULL UNIQUE, -- Resource being locked
  holder TEXT NOT NULL,           -- Agent holding lock
  seq INTEGER NOT NULL,           -- CAS sequence number
  acquired_at BIGINT NOT NULL,
  expires_at BIGINT NOT NULL,
  UNIQUE(resource)
);
```

**DurableLock uses this for file reservations and critical sections.**

---

#### `messages` - Materialized Message View

```sql
CREATE TABLE messages (
  id SERIAL PRIMARY KEY,
  project_key TEXT NOT NULL,
  from_agent TEXT NOT NULL,
  subject TEXT NOT NULL,
  body TEXT NOT NULL,
  thread_id TEXT,
  importance TEXT DEFAULT 'normal',
  created_at BIGINT NOT NULL,
  read_by JSONB DEFAULT '[]',   -- Array of agent names who read it
  acked_by JSONB DEFAULT '[]'   -- Array of agent names who acked it
);
```

**Built from `message_sent`, `message_read`, `message_acked` events.**

---

#### `message_recipients` - Message Routing

```sql
CREATE TABLE message_recipients (
  id SERIAL PRIMARY KEY,
  message_id INTEGER NOT NULL REFERENCES messages(id),
  agent_name TEXT NOT NULL,
  UNIQUE(message_id, agent_name)
);
CREATE INDEX idx_message_recipients_agent ON message_recipients(agent_name);
```

**Tracks which agents should see which messages (for inbox filtering).**

---

#### `reservations` - Active File Locks

```sql
CREATE TABLE reservations (
  id SERIAL PRIMARY KEY,
  project_key TEXT NOT NULL,
  agent_name TEXT NOT NULL,
  path_pattern TEXT NOT NULL,   -- File path or glob pattern
  exclusive BOOLEAN NOT NULL,
  reason TEXT,
  expires_at BIGINT NOT NULL
);
CREATE INDEX idx_reservations_agent ON reservations(agent_name);
CREATE INDEX idx_reservations_path ON reservations(path_pattern);
```

**Built from `file_reserved` events, expired entries removed by `file_released`.**

---

### Migrations

Schema versioning via `migrations.ts`:

```typescript
export const migrations: Migration[] = [
  {
    version: 1,
    description: "Add cursors table for DurableCursor",
    up: `CREATE TABLE cursors (...)`,
    down: `DROP TABLE cursors`,
  },
  {
    version: 2,
    description: "Add deferred table for DurableDeferred",
    up: `CREATE TABLE deferred (...)`,
    down: `DROP TABLE deferred`,
  },
  // ... more migrations
];
```

**Migrations run automatically on first database access.** New migrations are applied in order, version tracked in `schema_version` table.

---

## Effect-TS Integration

Swarm Mail is **built with Effect** - a functional effect system for TypeScript.

### Why Effect?

- âœ… **Composability** - combine primitives into patterns without callback hell
- âœ… **Type inference** - full TypeScript inference for errors and dependencies
- âœ… **Retries** - built-in retry schedules with exponential backoff
- âœ… **Resource safety** - `Effect.ensuring` guarantees cleanup (like try/finally)
- âœ… **Dependency injection** - Layers for services, no globals

### Services and Layers

Each primitive is an Effect **Service** (via `Context.Tag`):

```typescript
// Define service interface
export class DurableCursor extends Context.Tag("DurableCursor")<
  DurableCursor,
  DurableCursorService
>() {}

// Implement service
export const DurableCursorLive = DurableCursor.of({
  create: createCursorImpl,
});

// Use service in Effect
const program = Effect.gen(function* () {
  const cursor = yield* DurableCursor; // Service dependency
  const consumer = yield* cursor.create({ stream: "..." });
  // ...
});

// Provide service implementation
Effect.runPromise(program.pipe(Effect.provide(DurableCursorLive)));
```

**Layers compose** - higher-level services depend on lower-level ones:

```typescript
// DurableMailbox depends on DurableCursor
const MailboxLayer = Layer.mergeAll(CursorLayer, DurableMailboxLive);

// Ask pattern depends on Mailbox + Deferred
export const DurableAskLive = Layer.mergeAll(DurableDeferredLive, MailboxLayer);

// Use in program
const program = Effect.gen(function* () {
  const mailbox = yield* DurableMailbox;
  const response = yield* ask({ mailbox, to: "worker-2", payload: {...} });
});

Effect.runPromise(program.pipe(Effect.provide(DurableAskLive)));
```

### Error Handling

Effect has **typed errors** - errors are part of the Effect signature:

```typescript
// Effect<Success, Error, Requirements>
type MyEffect = Effect.Effect<number, LockError | TimeoutError, DurableLock>;

// Handle specific error types
yield *
  lockService.acquire("resource").pipe(
    Effect.catchTag("LockTimeout", () => Effect.succeed(null)),
    Effect.catchTag("LockContention", () => Effect.fail(new MyError())),
  );
```

---

## Use Cases and Examples

### Example 1: Swarm Worker Agent

**Scenario:** Worker agent receives subtask, reserves files, reports progress, completes.

```typescript
import { Effect } from "effect";
import { DurableAskLive } from "./streams/effect/layers";
import {
  initSwarmAgent,
  sendSwarmMessage,
  reserveSwarmFiles,
} from "./swarm-mail";

const program = Effect.gen(function* () {
  // 1. Initialize agent
  const { agentName, projectKey } = yield* Effect.promise(() =>
    initSwarmAgent({
      projectPath: "/abs/path",
      taskDescription: "bd-123.2: Auth service",
    }),
  );

  console.log(`Agent: ${agentName}`); // e.g., "DarkStone"

  // 2. Reserve files
  const { granted, conflicts } = yield* Effect.promise(() =>
    reserveSwarmFiles({
      projectPath: projectKey,
      agentName,
      paths: ["src/auth/**"],
      reason: "bd-123.2: Auth service",
      exclusive: true,
    }),
  );

  if (conflicts.length > 0) {
    console.warn("File conflicts detected:", conflicts);
  }

  // 3. Report progress
  yield* Effect.promise(() =>
    sendSwarmMessage({
      projectPath: projectKey,
      fromAgent: agentName,
      toAgents: ["coordinator"],
      subject: "Progress: bd-123.2",
      body: "Reserved files, starting work",
      threadId: "bd-123",
      importance: "normal",
    }),
  );

  // 4. Do work...
  yield* Effect.sleep("5 seconds");

  // 5. Report completion
  yield* Effect.promise(() =>
    sendSwarmMessage({
      projectPath: projectKey,
      fromAgent: agentName,
      toAgents: ["coordinator"],
      subject: "Complete: bd-123.2",
      body: "Auth service implemented",
      threadId: "bd-123",
      importance: "high",
    }),
  );
});

Effect.runPromise(program.pipe(Effect.provide(DurableAskLive)));
```

---

### Example 2: Request/Response with Ask Pattern

**Scenario:** Agent A asks Agent B for data, blocks until response.

```typescript
import { ask, respond } from "./streams/effect/ask";
import { DurableAskLive } from "./streams/effect/layers";

// Agent A (requester)
const agentA = Effect.gen(function* () {
  const mailboxService = yield* DurableMailbox;
  const mailbox = yield* mailboxService.create({
    agent: "agent-a",
    projectKey: "proj",
  });

  console.log("Requesting user data...");

  const response = yield* ask<Request, Response>({
    mailbox,
    to: "agent-b",
    payload: { userId: 123 },
    ttlSeconds: 30,
  });

  console.log("Got response:", response);
});

// Agent B (responder)
const agentB = Effect.gen(function* () {
  const mailboxService = yield* DurableMailbox;
  const mailbox = yield* mailboxService.create({
    agent: "agent-b",
    projectKey: "proj",
  });

  console.log("Listening for requests...");

  for await (const envelope of mailbox.receive<Request>()) {
    console.log("Processing request:", envelope.payload);

    const result = { name: "John", id: envelope.payload.userId };

    yield* respond(envelope, result);
    yield* envelope.commit();
  }
});

// Run both agents in parallel
const program = Effect.all([agentA, agentB], { concurrency: "unbounded" });
Effect.runPromise(program.pipe(Effect.provide(DurableAskLive)));
```

---

### Example 3: Resumable Event Processing

**Scenario:** Worker consumes events, checkpoints position, resumes after crash.

```typescript
import { DurableCursor } from "./streams/effect/cursor";
import { DurableCursorLive } from "./streams/effect/layers";

const program = Effect.gen(function* () {
  const cursorService = yield* DurableCursor;

  const cursor = yield* cursorService.create({
    stream: "projects/foo/events",
    checkpoint: "workers/event-processor",
    batchSize: 50,
  });

  console.log("Starting from position:", yield* cursor.getPosition());

  for await (const msg of cursor.consume()) {
    console.log("Processing event:", msg.value);

    // Simulate processing
    yield* Effect.sleep("100 millis");

    // Checkpoint position
    yield* msg.commit();
  }
});

Effect.runPromise(program.pipe(Effect.provide(DurableCursorLive)));

// If this crashes, next run starts from last committed position
```

---

## Diagrams

### Message Flow Between Agents

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Agent A  â”‚                    â”‚ Event Stream â”‚                    â”‚  Agent B  â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
      â”‚                                 â”‚                                  â”‚
      â”‚ 1. Send message                 â”‚                                  â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                                  â”‚
      â”‚    { to: "agent-b",             â”‚ 2. Append message_sent event     â”‚
      â”‚      payload: {...} }           â”‚    (id=42, seq=100)              â”‚
      â”‚                                 â”‚                                  â”‚
      â”‚                                 â”‚ 3. Update message view           â”‚
      â”‚                                 â”‚    INSERT INTO messages (...)    â”‚
      â”‚                                 â”‚                                  â”‚
      â”‚                                 â”‚                                  â”‚
      â”‚                                 â”‚         4. Agent B consumes      â”‚
      â”‚                                 â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚                                 â”‚    DurableCursor.consume()       â”‚
      â”‚                                 â”‚    afterSequence=99              â”‚
      â”‚                                 â”‚                                  â”‚
      â”‚                                 â”‚ 5. Return events                 â”‚
      â”‚                                 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
      â”‚                                 â”‚    [{ seq=100, type=msg_sent }]  â”‚
      â”‚                                 â”‚                                  â”‚
      â”‚                                 â”‚    6. Process message            â”‚
      â”‚                                 â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚                                 â”‚       msg.commit()               â”‚
      â”‚                                 â”‚                                  â”‚
      â”‚                                 â”‚ 7. Checkpoint position=100       â”‚
      â”‚                                 â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚                                 â”‚                                  â”‚
```

---

### File Reservation Protocol (CAS Lock)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Agent A  â”‚                                          â”‚ Agent B  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                                          â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚                                                     â”‚
     â”‚ 1. Reserve src/auth.ts                             â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
     â”‚                             â”‚                      â”‚
     â”‚ 2. DurableLock.acquire()    â”‚                      â”‚
     â”‚    INSERT INTO locks        â”‚                      â”‚
     â”‚    VALUES ('src/auth.ts',   â”‚                      â”‚
     â”‚            'AgentA',         â”‚                      â”‚
     â”‚            seq=0)            â”‚                      â”‚
     â”‚    â†’ SUCCESS                 â”‚                      â”‚
     â”‚                             â”‚                      â”‚
     â”‚ 3. Edit src/auth.ts         â”‚                      â”‚
     â”‚                             â”‚                      â”‚
     â”‚                             â”‚    4. Reserve src/auth.ts
     â”‚                             â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                             â”‚    â”‚                      â”‚
     â”‚                             â”‚    â”‚ 5. TRY INSERT        â”‚
     â”‚                             â”‚    â”‚    â†’ CONFLICT        â”‚
     â”‚                             â”‚    â”‚                      â”‚
     â”‚                             â”‚    â”‚ 6. TRY UPDATE        â”‚
     â”‚                             â”‚    â”‚    WHERE expires_at  â”‚
     â”‚                             â”‚    â”‚    < now OR          â”‚
     â”‚                             â”‚    â”‚    holder='AgentB'   â”‚
     â”‚                             â”‚    â”‚    â†’ 0 rows          â”‚
     â”‚                             â”‚    â”‚                      â”‚
     â”‚                             â”‚    â”‚ 7. Retry with        â”‚
     â”‚                             â”‚    â”‚    exponential       â”‚
     â”‚                             â”‚    â”‚    backoff...        â”‚
     â”‚                             â”‚    â”‚                      â”‚
     â”‚ 8. Release lock             â”‚    â”‚                      â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚                      â”‚
     â”‚                             â”‚    â”‚                      â”‚
     â”‚ 9. DELETE FROM locks        â”‚    â”‚ 10. Retry succeeds   â”‚
     â”‚    WHERE resource=...       â”‚    â”‚     UPDATE (0 rows   â”‚
     â”‚    AND holder='AgentA'      â”‚    â”‚     before, now      â”‚
     â”‚                             â”‚    â”‚     lock is free)    â”‚
     â”‚                             â”‚    â”‚     â†’ SUCCESS        â”‚
     â”‚                             â”‚    â”‚                      â”‚
```

---

### Ask Pattern (Request/Response)

```mermaid
sequenceDiagram
    participant A as Agent A
    participant D as DurableDeferred
    participant M as Mailbox
    participant B as Agent B

    A->>D: create({ ttl: 60s })
    D-->>A: url: "deferred:abc123"
    A->>M: send(to: B, { payload, replyTo: url })
    M->>B: Envelope delivered
    B->>B: Process request
    B->>D: resolve(url, response)
    D-->>A: Response (unblocks)
```

---

### Event Stream Structure

```
events table (append-only log):

â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ id â”‚ sequence â”‚     type     â”‚   timestamp   â”‚           payload           â”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1 â”‚    1     â”‚ agent_reg... â”‚ 1704000000000 â”‚ { agent: "AgentA", ... }    â”‚
â”‚  2 â”‚    2     â”‚ message_sent â”‚ 1704000001000 â”‚ { from: "A", to: ["B"] }    â”‚
â”‚  3 â”‚    3     â”‚ file_reserv. â”‚ 1704000002000 â”‚ { agent: "A", paths: [...]} â”‚
â”‚  4 â”‚    4     â”‚ message_read â”‚ 1704000003000 â”‚ { message_id: 2, agent: "B"}â”‚
â”‚  5 â”‚    5     â”‚ file_releas. â”‚ 1704000004000 â”‚ { agent: "A", paths: [...]} â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                     â–²
                                     â”‚
                                     â”‚  DurableCursor reads from here
                                     â”‚  Checkpoints last sequence number
                                     â”‚
                             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                             â”‚  cursors table    â”‚
                             â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                             â”‚ checkpoint: "..."  â”‚
                             â”‚ position: 4       â”‚ â† Resume from seq=5
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Credits and Inspiration

- **[Kyle Matthews](https://twitter.com/kylemathews)** (Founder/CPO @ [Electric SQL](https://electric-sql.com/)) - The Durable Streams protocol and the insight that composable primitives can build powerful actor systems. [Original tweet](https://x.com/kylemathews/status/1999896667030700098)
- **[Agent Mail](https://github.com/sst/opencode)** - Multi-agent coordination layer for OpenCode (SST). Swarm Mail's API surface is heavily inspired by Agent Mail's design.
- **[Electric SQL](https://electric-sql.com/)** - Real-time sync engine for Postgres. The cursor pattern and positioned consumption ideas come from Electric's sync protocol.
- **[Effect-TS](https://effect.website/)** - Functional effect system powering the implementation. Effect's composability and type safety make the primitives ergonomic.

---

## What's Next?

Swarm Mail is **production-ready** but has room for optimization:

### Performance Improvements

- [ ] **LISTEN/NOTIFY** - replace deferred polling with Postgres LISTEN/NOTIFY for instant wakeup
- [ ] **Connection pooling** - reuse PGLite connections instead of opening new ones
- [ ] **Batch inserts** - batch multiple events into one transaction
- [ ] **Index tuning** - add covering indexes for hot queries

### Features

- [ ] **Message priorities** - priority queue for urgent messages
- [ ] **Dead letter queue** - failed messages go to DLQ for retry
- [ ] **Message TTL** - auto-expire old messages
- [ ] **Broadcast channels** - pub/sub for topic-based routing
- [ ] **Saga pattern** - distributed transactions with compensations

### Developer Experience

- [ ] **DevTools UI** - web UI for inspecting events, cursors, locks
- [ ] **CLI tools** - `swarm-mail inspect`, `swarm-mail replay`
- [ ] **Metrics** - Prometheus metrics for message latency, lock contention
- [ ] **Tracing** - OpenTelemetry spans for distributed tracing

---

## Summary

Swarm Mail is an **embedded, event-sourced actor system** for multi-agent coordination. It provides:

- âœ… **Durable Streams primitives** - DurableCursor, DurableDeferred, DurableLock, DurableMailbox
- âœ… **Composable patterns** - Ask pattern (RPC), file reservations (CAS locks)
- âœ… **Effect-TS integration** - type-safe, composable, dependency-injected
- âœ… **Local-first** - embedded PGLite, zero network dependencies
- âœ… **Event sourcing** - full audit trail, time travel debugging
- âœ… **Resumable** - checkpointed cursors for exactly-once processing

**Use it when you need multi-agent coordination without external servers.**

---

```
    *    *  ğŸ  *    *
  *    *    *    *    *
    ğŸ   SHIP IT   ğŸ
  *    *    *    *    *
    *    *  ğŸ  *    *
```
